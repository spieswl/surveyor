#include "surveyor_remode/DepthmapOutput.h"

#include <ros/ros.h>
#include <ros/package.h>
#include <sensor_msgs/image_encodings.h>
#include <sensor_msgs/Image.h>
#include <sensor_msgs/CameraInfo.h>
#include <cv_bridge/cv_bridge.h>

#include <rmd/check_cuda_device.h>
#include <rmd/se3.cuh>


void surveyor::RemodeNode::RemodeNode(ros::NodeHandle &nh, std::string data_dir)
{
    this->nh_ = nh;

    this->sequence_path_ = data_dir;
    this->calib_file_ = sequence_path_ + "/camera.txt";
    this->distort_file_ = sequence_path_ + "/distort.txt";
    this->pose_file_ = sequence_path_ + "/pose.txt";

    this->num_msgs_ = 0;
    this->state_ = surveyor::RemodeState::TAKE_REFERENCE_FRAME;

    // should this actually go here? check this out later... -WLS
    this->pose_reader_.open(this->pose_file_, std::ios::in);

    this->ref_compl_perc_ = 10.0;                   // REMODE Depthmap Node default values
    this->max_dist_from_ref_ = 0.5;                 // Reevaluate these after pipeline is fully operational
    this->publish_conv_every_n_ = 10;               // (Originals found in "rpg_open_remode/src/depthmap_node.cpp")
}


void surveyor::RemodeNode::initNode()
{
    const float cam_fx, cam_fy, cam_cx, cam_cy;
    const size_t cam_width, cam_height;
    const float dist_k1, dist_k2, dist_p1, dist_p2;

    // Extract camera calibration parameters from the original dataset
    // Apply them to the depthmap generated by REMODE
    this->calib_reader_.open(this->calib_file_, std::ios::in)

    this->calib_reader_.close(this->calib_file_);

    this->depthmap_ = std::make_shared<rmd::Depthmap(cam_width, cam_height, cam_fx, cam_fy, cam_cx, cam_cy);

    // Extract camera distortion parameters from the original dataset
    // Apply them to the depthmap generated by REMODE
    this->distort_reader_.open(this->distort_file_, std::ios::in);

    this->distort_reader_.close(this->distort_file_);

    this->depthmap_->initUndistortion_Map(dist_k1, dist_k2, dist_p1, dist_p2);

    // Initialize the built-in REMODE ROS publisher functionality
    this->publisher_.reset(new rmd::Publisher(this->nh_, this->depthmap_));
}

void surveyor::RemodeNode::videoCallback(const sensor_msgs::ImageConstPtr inputImage)
{
    cv_bridge::CvImagePtr cv_ptr = cv_bridge::toCvCopy(inputImage, sensor_msgs::image_encodings::MONO8);

    assert(cv_ptr->image.type() == CV_8U);
    assert(cv_ptr->image.channels() == 1);

    // TODO: FINISH
}


int main(int argc, char** argv)
{
    if(!rmd::checkCudaDevice(argc, argv))
    {
        ROS_ERROR("SURVEYOR-REMODE : Compatible CUDA device not found! Shutting down...");
        return 5;
    }

    std::string param_name, data_dir, sequence_name, calib_file, pose_file;

    ros::init(argc, argv, "surveyor_remode");
    ros::NodeHandle nh;

    // Check the ROS parameter server for "sequence", which will define the location of the data to check
    // for the calibration and pose files.
    if(nh.searchParam("/camera_emulator/sequence", param_name))
    {
        nh.getParam(param_name, sequence_name);

        data_dir = ros::package::getPath("surveyor") + "/data/" + sequence_name;

        calib_file = data_dir + "/camera.txt";
        pose_file = data_dir + "/pose.txt";
    }
    else
    {
        ROS_ERROR("SURVEYOR-REMODE : No parameter named 'sequence'!");
        return 5;
    }

    surveyor::RemodeNode srv_rmd_node(nh, data_dir);
    srv_rmd_node.initNode();

    ros::Subscriber imgSub = nh.subscribe("source", 1, &surveyor::RemodeNode::videoCallback, &srv_rmd_node);

    ros::spin();

    return 0;
}