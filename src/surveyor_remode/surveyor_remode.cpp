#include "surveyor_remode/DepthmapOutput.h"

#include <ros/ros.h>
#include <ros/package.h>
#include <sensor_msgs/image_encodings.h>
#include <sensor_msgs/Image.h>
#include <sensor_msgs/CameraInfo.h>
#include <cv_bridge/cv_bridge.h>

#include <rmd/check_cuda_device.h>
#include <rmd/se3.cuh>


void surveyor::RemodeNode::RemodeNode(ros::NodeHandle &nh, std::string data_dir)
{
    this->nh_ = nh;

    this->sequence_path_ = data_dir;
    this->calib_file_ = sequence_path_ + "/camera.txt";
    this->distort_file_ = sequence_path_ + "/distort.txt";
    this->pose_file_ = sequence_path_ + "/pose.txt";

    this->frame_ID_ = 0;
    this->num_msgs_ = 0;
    this->state_ = surveyor::RemodeState::TAKE_REFERENCE_FRAME;

    this->ref_compl_perc_ = 10.0;                   // REMODE Depthmap Node default values
    this->max_dist_from_ref_ = 0.5;                 // Reevaluate these after pipeline is fully operational
    this->publish_conv_every_n_ = 10;               // (Originals found in "rpg_open_remode/src/depthmap_node.cpp")

    // NOTE: This looks hacky but I drew it straight from SVO's "exportToDense" member function in the Visualizer class. ¯\_(ツ)_/¯
    this->min_z_ = (float) std::numeric_limits<double>::max();
    this->max_z_ = (float) std::numeric_limits<double>::min();
    // NOTE: Also, that is not a mistake (as far as I know): max() goes to min_z_ and vice versa.

    ROS_INFO_STREAM("SURVEYOR-REMODE : Created ROS interface node to REMODE.");
    ROS_INFO_STREAM("SURVEYOR-REMODE : Data directory path referenced to " << this->sequence_path_);
}

void surveyor::RemodeNode::initNode()
{
    const float cam_fx, cam_fy, cam_cx, cam_cy, omega;
    const size_t cam_width, cam_height;
    const float dist_k1, dist_k2, dist_p1, dist_p2;

    // Extract camera calibration parameters from the original dataset
    // Apply them to the depthmap generated by REMODE
    this->calib_reader_.open(this->calib_file_, std::ios::in)

    this->calib_reader_ >> cam_fx;
    this->calib_reader_ >> cam_fy;
    this->calib_reader_ >> cam_cx;
    this->calib_reader_ >> cam_cy;
    this->calib_reader_ >> omega;             // Not currently used

    this->calib_reader_ >> cam_width;
    this->calib_reader_ >> cam_height;

    this->calib_reader_.close(this->calib_file_);

    // TODO: LOOK AT STANDARDIZING CALIBRATION PARAMS ACROSS ALL CODE
    // Have to revert the "normalized" value in the calibration file back to the full value.
    cam_fx = cam_fx * cam_width;
    cam_fy = cam_fy * cam_height;
    cam_cx = cam_cx * cam_width;
    cam_cy = cam_cy * cam_height;

    this->depthmap_ = std::make_shared<rmd::Depthmap(cam_width, cam_height, cam_fx, cam_fy, cam_cx, cam_cy);

    // Extract camera distortion parameters from the original dataset
    // Apply them to the depthmap generated by REMODE
    this->distort_reader_.open(this->distort_file_, std::ios::in);

    this->distort_reader_ >> dist_k1;
    this->distort_reader_ >> dist_k2;
    this->distort_reader_ >> dist_p1;
    this->distort_reader_ >> dist_p2;

    this->distort_reader_.close(this->distort_file_);

    this->depthmap_->initUndistortion_Map(dist_k1, dist_k2, dist_p1, dist_p2);

    // Initialize the built-in REMODE ROS publisher functionality
    this->publisher_.reset(new rmd::Publisher(this->nh_, this->depthmap_));
}

void surveyor::RemodeNode::videoCallback(const sensor_msgs::ImageConstPtr &inputImage)
{
    cv::Mat img_8UC1;

    std::ifstream pose_reader(this->pose_file_);
    std::string pose_line;
    int pose_ID = 0;

    float r[9] = { 0.0 };
    float t[3] = { 0.0 };

    this-> frame_ID_ += 1;
    this-> num_msgs_ += 1;

    cv_bridge::CvImageConstPtr cv_ptr = cv_bridge::toCvShare(const sensor_msgs::ImageConstPtr &inputImage,
                                                             const sensor_msgs::image_encodings::MONO8);
    img_8UC1 = cv_ptr->image;

    // Extract pose information for the image frame of note by sweeping the pose file line-by-line
    // Package it up to send to the REMODE publisher
    while(std::getline(pose_reader, pose_line))
    {
        std::istringstream input_string(pose_line);

        input_string >> pose_ID;

        if(pose_ID != this->frame_ID_)
        {
            continue;
        }
        else
        {
            // Row 1
            input_string >> r[0];
            input_string >> r[1];
            input_string >> r[2];
            input_string >> t[0];

            // Row 2
            input_string >> r[3];
            input_string >> r[4];
            input_string >> r[5];
            input_string >> t[1];

            // Row 3
            input_string >> r[6];
            input_string >> r[7];
            input_string >> r[8];
            input_string >> t[2];

            break;
        }
    }

    rmd::SE3<float> T_world_curr(&r, &t);

    switch(this->state_)
    {
        case surveyor::RemodeState::TAKE_REFERENCE_FRAME:
        {
            if(this->depthmap_->setReferenceImage(img_8UC1, T_world_curr.inv(), this->min_z_, this->max_z_))
            {
                this->state_ = RemodeState::UPDATE;
            }
            else
            {
                ROS_ERROR("SURVEYOR-REMODE : Could not set reference image!");
            }
            break;
        }

        case surveyor::RemodeState::UPDATE:
        {
            this->depthmap_->update(img_8UC1, T_world_curr.inv());

            const float perc_conv = this->depthmap_->getConvergedPercentage();
            const float dist_from_ref = this->depthmap_->getDistFromRef();

            ROS_INFO_STREAM("SURVEYOR-REMODE : Percentage of converged measurements = " << perc_conv);

            if(perc_conv > this->ref_compl_perc_ || dist_from_ref > this->max_dist_from_ref_)
            {
                this->state_ = RemodeState::TAKE_REFERENCE_FRAME;
                denoiseAndPublishResults();
            }
            break;
        }

        default:
        {
            break;
        }
    }

    if(this->publish_conv_every_n_ < this->num_msgs_)
    {
        publishConvergenceMap();
        this->num_msgs_ = 0;
    }
}

void surveyor::RemodeNode::denoiseAndPublishResults()
{
    this->depthmap_->downloadDenoisedDepthmap(0.5f, 200);
    this->depthmap_->downloadConvergenceMap();

    std::async(std::launch::async, &rmd::Publisher::publishDepthmapAndPointCloud, *publisher_);
}

void surveyor::RemodeNode::publishConvergenceMap()
{
    this->depthmap_->downloadConvergenceMap();

    std::async(std::launch::async, &rmd::Publisher::publishConvergenceMap, *publisher_);
}


int main(int argc, char** argv)
{
    if(!rmd::checkCudaDevice(argc, argv))
    {
        ROS_ERROR("SURVEYOR-REMODE : Compatible CUDA device not found! Shutting down...");
        return 5;
    }

    std::string param_name, data_dir, sequence_name, calib_file, pose_file;

    ros::init(argc, argv, "surveyor_remode");
    ros::NodeHandle nh;

    // Check the ROS parameter server for "sequence", which will define the location of the data to check
    // for the calibration and pose files.
    if(nh.searchParam("/camera_emulator/sequence", param_name))
    {
        nh.getParam(param_name, sequence_name);

        data_dir = ros::package::getPath("surveyor") + "/data/" + sequence_name;

        calib_file = data_dir + "/camera.txt";
        pose_file = data_dir + "/pose.txt";
    }
    else
    {
        ROS_ERROR("SURVEYOR-REMODE : No parameter named 'sequence'!");
        return 5;
    }

    surveyor::RemodeNode srv_rmd_node(nh, data_dir);
    srv_rmd_node.initNode();

    ros::Subscriber imgSub = nh.subscribe("source", 1, &surveyor::RemodeNode::videoCallback, &srv_rmd_node);

    ros::spin();

    return 0;
}